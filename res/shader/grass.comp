#version 430

layout(local_size_x = 16, local_size_y = 16) in;

// Readonly images (rgba8). We'll use .r as height/mask in [0..1].
layout(binding = 0, rgba8) readonly uniform image2D heightImg;
layout(binding = 1, rgba8) readonly uniform image2D maskImg;

// Output SSBO: [count(uint)] + instances[]
struct GrassInstance {
    vec4 pos_scale;   // xyz = position, w = scale
    vec4 nrm_yaw;     // xyz = normal,   w = yaw (radians)
};

layout(std430, binding = 2) buffer OutBuffer {
    uint count;
    GrassInstance inst[];
} outBuf;

uniform ivec2 heightSize;     // (width,height)
uniform vec3  terrainOrigin;  // world-space origin of heightmap (your t.pos)
uniform vec3  terrainSize;    // world size in x,z and height scale in y
uniform float density;        // 0..1 (probability per texel)
uniform float maskThreshold;  // 0..1
uniform float maxSlopeCos;    // e.g. cos(radians(40)) to reject steep slopes
uniform uint  maxInstances;   // hard cap to prevent overflow

uint hash_u32(uvec2 v) {
    v = v * 1664525u + 1013904223u;
    v.x ^= v.y; v.y ^= v.x;
    v = v * 22695477u + 1u;
    return v.x ^ (v.y << 16);
}
float hash01(uvec2 v) {
    return float(hash_u32(v) & 0x00FFFFFFu) / float(0x01000000u);
}

float heightAt(ivec2 c) {
    c = clamp(c, ivec2(0), heightSize - ivec2(1));
    return imageLoad(heightImg, c).r; // 0..1
}

void main() {
    ivec2 c = ivec2(gl_GlobalInvocationID.xy);
    if (c.x >= heightSize.x || c.y >= heightSize.y) return;

    float m = imageLoad(maskImg, c).r;
    if (m < maskThreshold) return;

    // spawn probability
    float r = hash01(uvec2(c));
    if (r > density) return;

    // normal from central differences in heightfield
    float hl = heightAt(c + ivec2(-1, 0));
    float hr = heightAt(c + ivec2( 1, 0));
    float hd = heightAt(c + ivec2( 0,-1));
    float hu = heightAt(c + ivec2( 0, 1));

    // world-space steps per texel
    vec2 texelWorld = vec2(terrainSize.x / float(heightSize.x - 1),
                           terrainSize.z / float(heightSize.y - 1));

    vec3 dx = vec3(2.0 * texelWorld.x, (hr - hl) * terrainSize.y, 0.0);
    vec3 dz = vec3(0.0, (hu - hd) * terrainSize.y, 2.0 * texelWorld.y);

    vec3 n = normalize(cross(dz, dx)); // up-ish normal

    // slope reject
    if (n.y < maxSlopeCos) return;

    // compute world position (x,z from texel, y from height)
    float h = heightAt(c) * terrainSize.y;

    vec3 pos = terrainOrigin +
        vec3(float(c.x) * texelWorld.x, h, float(c.y) * texelWorld.y);

    // append
    uint idx = atomicAdd(outBuf.count, 1u);
    if (idx >= maxInstances) return;

    float yaw = hash01(uvec2(c) ^ uvec2(123u, 456u)) * 6.28318530718;
    float sc  = mix(0.6, 1.2, hash01(uvec2(c) ^ uvec2(999u, 111u)));

    outBuf.inst[idx].pos_scale = vec4(pos, sc);
    outBuf.inst[idx].nrm_yaw   = vec4(n, yaw);
}
