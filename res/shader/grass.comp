#version 430
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Blade { vec4 posH; }; // xyz + height

layout(std430, binding = 0) readonly buffer InBlades  { Blade inB[]; };
layout(std430, binding = 1) writeonly buffer VisibleBlades { Blade outB[]; };
layout(std430, binding = 2) buffer Counter { uint visibleCount; };

uniform vec3 uCameraPos;
uniform uint uSeed;
uniform float uRadius;
uniform uint uMaxVisible;

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

uint hash2(float x, float y, uint seed) {
    uint ux = uint(x * float(1664525u + 1013904223u));
    uint uy = uint(y * float(22695477u + 1u));
    return hash_u32(ux ^ (uy + seed));
}

float u01(uint h) { return float(h) * (1.0 / 4294967295.0); }


void main() {
    uint id = gl_GlobalInvocationID.x;
    if (inB[id].posH.x == 0.0 && inB[id].posH.y == 0.0 && inB[id].posH.z == 0.0) return;

    // decrease clumping as distance increases
    float dist = length(vec3(float(inB[id].posH.x - uCameraPos.x), float(inB[id].posH.y - uCameraPos.y), float(inB[id].posH.z - uCameraPos.z)));
    float d = sqrt(max((dist/uRadius - 1), 0.0));
    float keepP = sqrt(1.0 * sqrt(exp(-2 - 2 * d)));
    
    // deterministic per-cell randomness
    uint h = hash2(inB[id].posH.x, inB[id].posH.z, uSeed);
    
    // deterministic per-cell decision so it doesn't flicker frame-to-frame
    float roll = u01(hash_u32(h ^ 0x9E3779B9u));
    if (roll > keepP) return;

    uint idx = atomicAdd(visibleCount, 1u);
    if (idx >= uMaxVisible) return;

    outB[idx] = inB[id];
}
