#version 430
layout(local_size_x = 16, local_size_y = 16) in;

struct Blade { vec4 posH; }; // xyz + height

layout(std430, binding = 1) writeonly buffer VisibleBlades { Blade outB[]; };
layout(std430, binding = 2) buffer Counter { uint visibleCount; };

uniform vec3  uCameraPos;    // world
uniform uint  uSeed;
uniform float uRadius;       // meters
uniform float uCellSize;     // meters between candidate cells (e.g. 0.5)
uniform int  uMaxVisible;

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

uint hash2(int x, int y, uint seed) {
    uint ux = uint(x) * 1664525u + 1013904223u;
    uint uy = uint(y) * 22695477u + 1u;
    return hash_u32(ux ^ (uy + seed));
}

float u01(uint h) { return float(h) * (1.0 / 4294967295.0); }

void main() {
    // grid coordinates in a (2Rcells x 2Rcells) square
    float rCellsF = ceil(uRadius / uCellSize);
    int   rCells  = int(rCellsF);
    int   size    = rCells * 2;

    ivec2 g = ivec2(gl_GlobalInvocationID.xy);
    if (g.x >= size || g.y >= size) return;

    // world cell coordinate of camera
    int camCellX = int(floor(uCameraPos.x));
    int camCellZ = int(floor(uCameraPos.z));

    // this invocation's world cell
    int cellX = camCellX + (g.x - rCells);
    int cellZ = camCellZ + (g.y - rCells);

    // deterministic per-cell randomness
    uint h = hash2(cellX, cellZ, uSeed);

    // jitter inside the cell, but anchored to cell coords
    float jx = u01(hash_u32(h ^ 0xA511E9B3u));
    float jz = u01(hash_u32(h ^ 0x63D83595u));

    float worldX = (float(cellX) + jx) * uCellSize;
    float worldZ = (float(cellZ) + jz) * uCellSize;


    float H = mix(0.35, 1.10, u01(hash_u32(h ^ 0xC2B2AE35u)));

    uint idx = atomicAdd(visibleCount, 1u);
    if (idx >= uMaxVisible) return;

    outB[idx].posH = vec4(worldX, 0.5, worldZ, H);
}
